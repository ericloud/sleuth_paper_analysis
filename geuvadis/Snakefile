include: '../config.py'

from os.path import isfile

isoform_simulations = [
    'sims/isoform_{a}_{b}_{rep}_{seed}_{sf_mode}'.
        format(a = 3, b = 3, rep = 5, seed = 1, sf_mode = 1)
]

def generate_reads(simulation_string):
    base = '{}/exp_'.format(simulation_string)
    mode, n_a, n_b, n_sim, seed, sf = simulation_string.split('_')
    n_sim = int(n_sim)
    n = int(n_a) + int(n_b)
    sims = []
    for i in range(1, n_sim + 1):
        current_experiment = base + str(i)
        for j in range(1, n + 1):
            current_simulation_1 = '{b}/{id}/sim_{id}_1.fq.gz'.format(
                b = current_experiment, id = j)
            current_simulation_2 = '{b}/{id}/sim_{id}_2.fq.gz'.format(
                b = current_experiment, id = j)
            sims.append(current_simulation_1)
            sims.append(current_simulation_2)
    return sims

def generate_base(simulation_string):
    base = '{}/exp_'.format(simulation_string)
    mode, n_a, n_b, n_sim, seed, sf = simulation_string.split('_')
    n_sim = int(n_sim)
    n = int(n_a) + int(n_b)
    sims = []
    for i in range(1, n_sim + 1):
        current_experiment = base + str(i)
        for j in range(1, n + 1):
            sims.append(current_experiment + '/' + str(j))
    return sims

def get_simulation_info(experiment_string):
    mode, a, b, n, seed, sf = experiment_string.split('_')
    result = {
        'mode': mode,
        'a': int(a),
        'b': int(b),
        'n': int(n),
        'seed': int(seed),
        'sf': int(sf)
    }
    return result

def get_all_ids(wildcards, expansion_string):
    info = get_simulation_info(wildcards['experiment'])
    all_ids = range(1, info['a'] + info['b'] + 1)
    print('in here!', all_ids)
    return expand(expansion_string, id = all_ids)

generate_reads(isoform_simulations[0])

def generate_files(specific_replication, suffix):
    return [b + suffix for b in generate_base(specific_replication)]

# isoform_reads = [generate_reads(current_reads) for current_reads in isoform_simulations]
# isoform_bam = [b + '/hisat.bam' for b in generate_base(isoform_simulations[0])]
# isoform_kallisto = [b + '/kallisto/abundance.h5' for b in generate_base(isoform_simulations[0])]
# isoform_feature_counts = [b + '/featureCounts.txt' for b in generate_base(isoform_simulations[0])]
# print(isoform_feature_counts)

# print(generate_files(isoform_simulations[0], '/hisat.bam'))

# print(isoform_reads[0][0:5])
# print(isoform_bam[0:4])
def get_ids(wildcards, file_prefix, file_suffix):
    experiment = wildcards['experiment']
    num = wildcards['num']

    info = get_simulation_info(experiment)

    # prefix = '{0}/{1}/exp_{2}/{3}'.format(file_prefix, experiment, num, )


# TODO: put this at the beginning of the pipeline (run it before everything)
FINN_SAMPLES = []
with open('finn_samples.txt', 'r') as input:
    for line in input:
        FINN_SAMPLES.append(line.strip())


FINN_NULL_SAMPLES = set()
with open('finn_null_experiment.txt', 'r') as input:
    for line in input:
        for sample in line.split():
            FINN_NULL_SAMPLES.add(sample)
print(FINN_NULL_SAMPLES)
print(len(FINN_NULL_SAMPLES))

rule all:
    input:
        # get all the metadata we need from geuvadis
        'metadata/geu_meta.RData',
        'results/prep_fin.RData',

        # used for null experiment
        expand('results/finn_samples/{id}/abundance.h5', id = FINN_SAMPLES),
        expand('results/finn_samples/{id}/hisat.bam', id = FINN_SAMPLES),
        expand('results/finn_samples/{id}/featureCounts.txt', id = FINN_SAMPLES),
        expand('results/finn_samples/{id}/cuffquant/abundances.cxb', id = FINN_SAMPLES),
        expand('results/finn_samples/null/{id}/cuffdiff/isoform_exp.diff', id = range(1, 21)),
        'results/null_resampling_fdr_report.html',

        # isoform_reads[0][0:5],
        # isoform_bam[0:5],
        # isoform_kallisto[0:6],
        # isoform_feature_counts[0:6],
        #
        # 'sims/isoform_3_3_5_1_1/exp_1/results/cuffdiff/isoform_exp.diff',
        # expand('sims/isoform_3_3_6_1_1/exp_{n}/results/cuffdiff/isoform_exp.diff',
        #     n = range(1, 7)),
        # 'sims/isoform_3_3_5_1_1/exp_1/results/featureCounts/counts.tsv',
        expand('sims/isoform_3_3_20_1_1/exp_{n}/results/sleuth',
            n = range(1, 20 + 1)),
        expand('sims/isoform_3_3_20_1_1/exp_{n}/results/cuffdiff/isoform_exp.diff',
            n = range(1, 20 + 1)),
        expand('sims/isoform_3_3_20_1_1/exp_{n}/results/featureCounts/counts.tsv',
            n = range(1, 20 + 1)),

        # 'sims/gcd_3_3_20_1_2/sims.rds'
        expand('sims/gcd_3_3_20_1_2/exp_{n}/results/sleuth',
            n = range(1, 20 + 1)),
        expand('sims/gcd_3_3_20_1_2/exp_{n}/results/featureCounts/counts.tsv',
            n = range(1, 20 + 1)),
        expand('sims/gcd_3_3_20_1_2/exp_{n}/results/cuffdiff/isoform_exp.diff',
            n = range(1, 20 + 1)),

        expand('sims/gfr_3_3_20_42_2/exp_{n}/results/sleuth',
            n = range(1, 20 + 1)),
        expand('sims/gfr_3_3_20_42_2/exp_{n}/results/featureCounts/counts.tsv',
            n = range(1, 20 + 1)),
        expand('sims/gfr_3_3_20_42_2/exp_{n}/results/cuffdiff/isoform_exp.diff',
            n = range(1, 20 + 1)),
        # isoform_simulations[0:5],
        # isoform_reads[0:5]

        # run BitSeq on 1 sample:
        expand('sims/gfr_3_3_20_42_2/exp_{num}/{id}/bowtie.bam',
            num = [1], id = range(1, 7)),
        # expand('sims/{experiment}/exp_{num}/{id}/BitSeq.rpkm',
        #     experiment = 'gfr_3_3_20_42_2', num = [1], id = range(1, 7)),
        expand('sims/{experiment}/exp_{num}/{id}/BitSeq_cli.{ext}',
            experiment = 'gfr_3_3_20_42_2', num = [1], id = range(1, 7),
            ext = ['tr', 'prob']),

        expand('sims/{experiment}/exp_{num}/{id}/BitSeq_cli.{ext}',
            experiment = 'gfr_3_3_20_42_2', num = [1], id = range(1, 7),
            ext = ['rpkm']),

        # do a large experiment so that we can do permutations
        'sims/gfr_10_11_1_43_2/exp_1/results/cuffdiff/isoform_exp.diff',
        'sims/gfr_10_11_1_43_2/exp_1/results/sleuth',
        'sims/gfr_10_11_1_43_2/exp_1/results/featureCounts/counts.tsv',

        expand('results/{experiment}/isoform_benchmarks.rds',
            experiment = ['gfr_3_3_20_42_2']),

        expand('results/{experiment}/1/rsem_sleuth.rds',
            experiment = ['gfr_3_3_20_42_2']),

        expand('results/{experiment}/gene_benchmarks.rds',
            experiment = ['gfr_3_3_20_42_2']),
        expand('results/{experiment}/benchmark_report.html',
            experiment = ['gfr_3_3_20_42_2', 'gcd_3_3_20_1_2',
            'isoform_3_3_20_1_1']),

        expand('results/{experiment}/benchmark_report_0_variance.html',
            experiment = ['gfr_3_3_20_42_2', 'gcd_3_3_20_1_2',
            'isoform_3_3_20_1_1']),

        expand('results/{experiment}/isoform_benchmarks_filter_poisson_variance.rds',
            experiment = ['gfr_3_3_20_42_2', 'gcd_3_3_20_1_2',
            'isoform_3_3_20_1_1']),

        expand('results/{experiment}/gene_benchmarks_filter_poisson_variance.rds',
            experiment = ['gfr_3_3_20_42_2', 'gcd_3_3_20_1_2',
            'isoform_3_3_20_1_1']),

        expand('results/{experiment}/isoform_benchmarks_filter_smooth_variance.rds',
            experiment = ['gfr_3_3_20_42_2', 'gcd_3_3_20_1_2',
            'isoform_3_3_20_1_1']),

        expand('results/{experiment}/gene_benchmarks_filter_smooth_variance.rds',
            experiment = ['gfr_3_3_20_42_2', 'gcd_3_3_20_1_2',
            'isoform_3_3_20_1_1']),

        expand('results/{experiment}/txi.rds',
            experiment = ['gfr_3_3_20_42_2', 'gcd_3_3_20_1_2',
            'isoform_3_3_20_1_1']),
        expand('results/{experiment}/benchmark_report_tximport.html',
            experiment = ['gfr_3_3_20_42_2', 'gcd_3_3_20_1_2',
            'isoform_3_3_20_1_1']),

        expand('results/training/gfr_10_11_1_43_2/exp_1/{p}/results/cuffdiff/isoform_exp.diff',
            p = range(1, 20 + 1)),
        expand('results/validation/gfr_10_11_1_43_2/exp_1/{p}/results/cuffdiff/isoform_exp.diff',
            p = range(1, 20 + 1)),
        'results/resampling/resampling_report.html',

        'results/resampling/resampling_figures_merge.html',

        expand('results/{experiment}/stratify_results.html',
            experiment = ['isoform_3_3_20_1_1']),

        expand('results/{experiment}/stratified_by_effect.html',
            experiment = ['gfr_3_3_20_42_2'])


rule geuvadis_metadata:
    output:
        'metadata/geu_meta.RData'
    shell:
        source_r('R', 'metadata.R')

rule prep_finnish_samples:
    input:
        'metadata/geu_meta.RData'
    output:
        'results/prep_fin.RData'
    shell:
        source_r('R', 'mean_disp_pairs.R')

def finn_sample_input(wildcards):
    id = wildcards['id']
    return expand('finn_samples/{id}/{id}_{i}.fastq.gz', id = id, i = [1, 2])

rule finn_samples:
    input:
        finn_sample_input
    output:
        'results/finn_samples/{id}/abundance.h5'
    threads: 5
    shell:
        '{UPDATED_PATH} '
        'kallisto quant'
        ' -i {KALLISTO_INDEX}'
        ' -b 30'
        ' -o {output[0]}'
        ' -t {threads}'
        ' {input[0]} {input[1]}'

rule finn_hisat_alignment:
    input:
        finn_sample_input
    output:
        'results/finn_samples/{id}/hisat.bam'
    threads: 10
    benchmark:
        'benchmark/finn_samples/{id}/hisat/benchmark.json'
    shell:
        '{UPDATED_PATH}'
        ' hisat2'
        ' -x {HISAT_INDEX}'
        ' -1 {input[0]}'
        ' -2 {input[1]}'
        ' --dta-cufflinks'
        ' -p {threads}'
        ' | '
        '{UPDATED_PATH} samtools view -Sb -'
        ' > '
        '{output}.unsorted'
        ' && '
        '{UPDATED_PATH} samtools sort'
        ' -o {output}'
        ' {output}.unsorted'
        ' && '
        'rm {output}.unsorted'

rule finn_featureCounts:
    input:
        'results/finn_samples/{id}/hisat.bam'
    output:
        'results/finn_samples/{id}/featureCounts.txt'
    benchmark:
        'benchmark/finn_samples/{id}/featureCounts/benchmark.json'
    threads: 2
    shell:
        '{UPDATED_PATH} '
        'featureCounts '
        ' -a {TRANSCRIPTOME_GTF}'
        ' -o {output}'
        ' -T {threads}'
        ' -p'
        ' {input}'


rule finn_cuffquant:
    input:
        'results/finn_samples/{id}/hisat.bam',
        TRANSCRIPTOME_GTF
    output:
        'results/finn_samples/{id}/cuffquant/abundances.cxb'
        # 'sims/{experiment}/exp_{num}/{id}/cuffquant/abundances.cxb'
    threads: 5
    benchmark:
        'benchmark/finn_samples/{id}/cuffquant/benchmark.json'
    params:
        output = 'results/finn_samples/{id}/cuffquant/'
    shell:
        '{UPDATED_PATH}'
        ' cuffquant'
        ' -p {threads}'
        ' -o {params.output}'
        ' -b {GENOME_FA}'
        ' -u'
        ' -q'
        ' {TRANSCRIPTOME_GTF}'
        ' {input[0]}'

FINN_NULL_SAMPLES = []
with open('finn_null_experiment.txt') as f:
    for line in f:
        line = line.split()
        FINN_NULL_SAMPLES.append(line)

def finn_get_samples(wildcards):
    id = int(wildcards['id'])
    id = id - 1
    samples = FINN_NULL_SAMPLES[id]
    return samples

def finn_get_cufflinks(wildcards):
    samples = finn_get_samples(wildcards)
    return expand('results/finn_samples/{id}/cuffquant/abundances.cxb',
        id = samples)

rule finn_cuffdiff:
    input:
        finn_get_cufflinks
    output:
        'results/finn_samples/null/{id}/cuffdiff',
        'results/finn_samples/null/{id}/cuffdiff/isoform_exp.diff',
        'results/finn_samples/null/{id}/cuffdiff/gene_exp.diff'
    benchmark:
        'benchmark/finn_samples/null/{id}/cuffdiff/benchmark.json'
    threads: 3
    run:
        samples = finn_get_cufflinks(wildcards)
        left = [samples[i] for i in range(0, 3)]
        right = [samples[i] for i in range(3, 6)]
        cmd = ' '.join([UPDATED_PATH,
            'cuffdiff',
            '-p', str(threads),
            '-o', output[0],
            '-b', GENOME_FA,
            '-u',
            '-q',
            TRANSCRIPTOME_GTF,
            ','.join(left),
            ','.join(right)
            ])
        print(cmd)
        shell(cmd)


rule null_resampling_isoform:
    input:
        expand('results/finn_samples/{id}/abundance.h5', id = FINN_SAMPLES),
        expand('results/finn_samples/{id}/featureCounts.txt', id = FINN_SAMPLES)
    output:
        'results/null_resampling/isoform.rds'
    threads: 20
    shell:
        source_r('R', 'null_resampling_fdr_isoform.R') + ' {threads}'

rule null_resampling_gene:
    input:
        expand('results/finn_samples/{id}/abundance.h5', id = FINN_SAMPLES),
        expand('results/finn_samples/{id}/featureCounts.txt', id = FINN_SAMPLES)
    output:
        'results/null_resampling/gene.rds'
    threads: 20
    shell:
        source_r('R', 'null_resampling_fdr_gene.R') + ' {threads}'

rule null_resampling_fdr_report:
    input:
        'results/null_resampling/isoform.rds',
        'results/null_resampling/gene.rds',
        expand('results/finn_samples/null/{id}/cuffdiff/isoform_exp.diff', id = range(1, 21))
    output:
        'results/null_resampling_fdr_report.html'
    shell:
        source_rmd('R', 'null_resampling_fdr_report.Rmd', '../results/null_resampling_fdr_report.html')

###
# simulation generation
###

# this simulation deals with modeling independent differential usage amongst the isoforms
# basically, every isoform is looked at independently and decides whether or not it will be
# differentially expressed independently.
rule gen_sim_script_isoform:
    input:
        'results/prep_fin.RData'
    output:
        'sims/isoform_{n_a,\d+}_{n_b}_{n_sim}_{seed,\d+}_{sf,\d+}',
        'sims/isoform_{n_a,\d+}_{n_b}_{n_sim}_{seed}_{sf}/sims.rds'
    shell:
        source_r('R', 'gen_sim.R') + ' '
        'isoform_{wildcards.n_a}_{wildcards.n_b}_{wildcards.n_sim}_{wildcards.seed}_{wildcards.sf} '
        ' {wildcards.n_sim}'
        ' {wildcards.n_a}'
        ' {wildcards.n_b}'
        ' {wildcards.seed}'
        ' {wildcards.sf}'

# gcd - gene differential expression with change in the same direction
#
# this simulation deals with the "best case" scenario when doing union counting.
# the simulation is performed by selecting a set of genes to be differentially expressed,
# then making every single transcript within that gene differentially expressed.
# the isoforms within a differentially expressed gene are then all moving in the same direction
rule gen_sim_script_geneCommonDirection:
    input:
        'results/prep_fin.RData'
    output:
        'sims/gcd_{n_a,\d+}_{n_b}_{n_sim}_{seed,\d+}_{sf,\d+}',
        'sims/gcd_{n_a,\d+}_{n_b}_{n_sim}_{seed}_{sf}/sims.rds'
    shell:
        source_r('R', 'gen_sim_gcd.R') + ' '
        'gcd_{wildcards.n_a}_{wildcards.n_b}_{wildcards.n_sim}_{wildcards.seed}_{wildcards.sf} '
        ' {wildcards.n_sim}'
        ' {wildcards.n_a}'
        ' {wildcards.n_b}'
        ' {wildcards.seed}'
        ' {wildcards.sf}'

# gfr - gene differential expression from reference
#
# this simulation uses the fold changes learned from a particular data set.
# it then simulates differential expression by choosing a gene to be differentially expressed,
# then making all of its fold changes the same as a gene in the reference data.
# the ranks of the gene expression are also matched so that we do not get
# extreme full changes for very highly expressed transcripts
rule gen_sim_script_geneFromReference:
    input:
        'results/prep_fin.RData',
        '../cuffdiff2_analysis/results/fc.rds'
    output:
        'sims/gfr_{n_a,\d+}_{n_b}_{n_sim}_{seed,\d+}_{sf,\d+}',
        'sims/gfr_{n_a,\d+}_{n_b}_{n_sim}_{seed}_{sf}/sims.rds'
    shell:
        source_r('R', 'gen_sim_gfr.R') + ' '
        'gfr_{wildcards.n_a}_{wildcards.n_b}_{wildcards.n_sim}_{wildcards.seed}_{wildcards.sf} '
        ' {wildcards.n_sim}'
        ' {wildcards.n_a}'
        ' {wildcards.n_b}'
        ' {wildcards.seed}'
        ' {wildcards.sf}'

rule make_simulation:
    input:
        'sims/{experiment}/sims.rds'
    output:
        'sims/{experiment}/exp_{num}/{id}/sim_{id}_1.fq.gz',
        'sims/{experiment}/exp_{num}/{id}/sim_{id}_2.fq.gz'
    params:
        sims = 'sims/{experiment}/exp_{num}/{id}'
    benchmark:
        'benchmark/{experiment}/exp_{num}/{id}/make_simulation/benchmark.json'
    shell:
        '{UPDATED_PATH}'
        ' {params.sims}/sim_{wildcards.id}.sh'
        ' {RSEM_ANNOTATION}'
        ' {RSEM_MODEL}'
        ' {params.sims}'

rule hisat_alignment:
    input:
        'sims/{experiment}/exp_{num}/{id}/sim_{id}_1.fq.gz',
        'sims/{experiment}/exp_{num}/{id}/sim_{id}_2.fq.gz'
    output:
        'sims/{experiment}/exp_{num}/{id}/hisat.bam'
    threads: 10
    benchmark:
        'benchmark/{experiment}/exp_{num}/{id}/hisat/benchmark.json'
    shell:
        '{UPDATED_PATH}'
        ' hisat2'
        ' -x {HISAT_INDEX}'
        ' -1 {input[0]}'
        ' -2 {input[1]}'
        ' --dta-cufflinks'
        ' -p {threads}'
        ' | '
        '{UPDATED_PATH} samtools view -Sb -'
        ' > '
        '{output}.unsorted'
        ' && '
        '{UPDATED_PATH} samtools sort'
        ' -o {output}'
        ' {output}.unsorted'
        ' && '
        'rm {output}.unsorted'

rule featureCounts:
    input:
        'sims/{experiment}/exp_{num,\d+}/{id,\d+}/hisat.bam'
    output:
        'sims/{experiment}/exp_{num,\d+}/{id,\d+}/featureCounts.txt'
    benchmark:
        'benchmark/{experiment}/exp_{num}/{id}/featureCounts/benchmark.json'
    threads: 5
    shell:
        '{UPDATED_PATH} '
        'featureCounts '
        ' -a {TRANSCRIPTOME_GTF}'
        ' -o {output}'
        ' -T {threads}'
        ' -p'
        ' {input}'

def get_feature_counts(wildcards):
    experiment = wildcards['experiment']
    info = get_simulation_info(experiment)
    num = wildcards['num']
    ids = range(1, info['a'] + info['b'] + 1)

    return expand(
        'sims/{experiment}/exp_{num}/{id}/featureCounts.txt',
        experiment = experiment,
        num = num,
        id = ids)

rule aggregate_counts:
    input:
        get_feature_counts
    output:
        'sims/{experiment}/exp_{num,\d+}/results/featureCounts/counts.tsv'
    params:
        base = 'sims/{experiment}/exp_{num}'
    threads: 1
    shell:
        source_r('R', 'merge_counts.R') +  ' ../{params.base} ../{output}'

rule cuffquant:
    input:
        'sims/{experiment}/exp_{num}/{id}/hisat.bam',
        TRANSCRIPTOME_GTF
    output:
        'sims/{experiment}/exp_{num}/{id}/cuffquant/abundances.cxb'
    threads: 5
    benchmark:
        'benchmark/{experiment}/exp_{num}/{id}/cuffquant/benchmark.json'
    params:
        output = 'sims/{experiment}/exp_{num}/{id}/cuffquant'
    shell:
        '{UPDATED_PATH}'
        ' cuffquant'
        ' -p {threads}'
        ' -o {params.output}'
        ' -b {GENOME_FA}'
        ' -u'
        ' -q'
        ' {TRANSCRIPTOME_GTF}'
        ' {input[0]}'

def get_cuffdiff(wildcards):
    experiment = wildcards['experiment']
    info = get_simulation_info(experiment)
    num = wildcards['num']
    ids = range(1, info['a'] + info['b'] + 1)
    return expand('sims/{experiment}/exp_{num}/{id}/cuffquant/abundances.cxb',
        experiment = experiment,
        num = num,
        id = ids)
rule cuffdiff:
    input:
        get_cuffdiff
    output:
        'sims/{experiment}/exp_{num,\d+}/results/cuffdiff',
        'sims/{experiment}/exp_{num}/results/cuffdiff/isoform_exp.diff',
        'sims/{experiment}/exp_{num}/results/cuffdiff/gene_exp.diff'
    benchmark:
        'benchmark/{experiment}/exp_{num}/cuffdiff/benchmark.json'
    threads: 3
    run:
        info = get_simulation_info(wildcards['experiment'])
        # I'm not sure if this is necessary, but at least this ensures they are sorted correctly
        input.sort(key = lambda x: int(x.split('/')[3]))
        left = [input[i] for i in range(0, info['a'])]
        right = [input[i] for i in range(info['a'], info['a'] + info['b'])]

        cmd = ' '.join([UPDATED_PATH,
            'cuffdiff',
            '-p', str(threads),
            '-o', output[0],
            '-b', GENOME_FA,
            '-u',
            '-q',
            TRANSCRIPTOME_GTF,
            ','.join(left),
            ','.join(right)
            ])
        print(cmd)
        shell(cmd)

rule kallisto:
    input:
        'sims/{experiment}/exp_{num}/{id}/sim_{id}_1.fq.gz',
        'sims/{experiment}/exp_{num}/{id}/sim_{id}_2.fq.gz'
    output:
        'sims/{experiment}/exp_{num}/{id}/kallisto',
        'sims/{experiment}/exp_{num}/{id}/kallisto/abundance.h5',
        'sims/{experiment}/exp_{num}/{id}/kallisto/abundance.tsv'
    benchmark:
        'benchmark/{experiment}/exp_{num}/{id}/kallisto/benchmark.json'
    threads: 5
    shell:
        '{UPDATED_PATH} '
        'kallisto quant'
        ' -i {KALLISTO_INDEX}'
        ' -b 100'
        ' -o {output[0]}'
        ' -t {threads}'
        ' {input[0]} {input[1]}'
        # ' <(zcat {input[0]}) <(zcat {input[1]})'

def get_sleuth(wildcards):
    experiment = wildcards['experiment']
    info = get_simulation_info(experiment)
    num = wildcards['num']
    ids = range(1, info['a'] + info['b'] + 1)
    return expand('sims/{experiment}/exp_{num}/{id}/kallisto/abundance.h5',
        experiment = experiment,
        num = num,
        id = ids)
rule sleuth:
    input:
        get_sleuth
    output:
        'sims/{experiment}/exp_{num,\d+}/results/sleuth'
    shell:
        'touch {output}'

N_SIM = 20
def get_gene_dependencies(wildcards):
    exp = wildcards['experiment']
    ret = []
    ret += expand('sims/{exp}/exp_{num}/results/sleuth', exp = exp,
        num = range(1, N_SIM + 1))
    ret += expand('sims/{exp}/exp_{num}/results/cuffdiff/gene_exp.diff', exp = exp,
        num = range(1, N_SIM + 1))
    ret += expand('sims/{exp}/exp_{num}/results/featureCounts/counts.tsv', exp = exp,
        num = range(1, N_SIM + 1))
    return ret
rule benchmark_gene:
    input:
        get_gene_dependencies
    output:
        'results/{experiment}/gene_benchmarks.rds'
    threads:
        N_SIM
    shell:
        source_r('R', 'bench_gene.R') + ' {threads} {wildcards.experiment}'

rule benchmark_gene_filter:
    input:
        get_gene_dependencies
    output:
        'results/{experiment}/gene_benchmarks_filter.rds'
    threads:
        N_SIM
    shell:
        source_r('R', 'best_filter_gene.R') + ' {threads} {wildcards.experiment}'

rule benchmark_gene_filter_lfc:
    input:
        'results/{experiment}/gene_benchmarks_filter.rds'
    output:
        'results/{experiment}/gene_benchmarks_filter_lfc.rds'
    threads:
        N_SIM
    shell:
        source_r('R', 'best_filter_gene_lfc.R') + ' {threads} {wildcards.experiment}'

rule benchmark_gene_tximport:
    input:
        'results/{experiment}/gene_benchmarks_filter.rds'
    output:
        'results/{experiment}/txi.rds'
    threads: N_SIM
    shell:
        source_r('R', 'best_filter_gene_tximport.R') + ' {threads} {wildcards.experiment}'

rule benchmark_report_tximport:
    input:
        'results/{experiment}/txi.rds'
    output:
        'results/{experiment}/benchmark_report_tximport.html'
    shell:
        source_rmd('R', 'benchmark_report_tximport.Rmd',
            '../results/{wildcards.experiment}/benchmark_report_tximport.html') +
        ' {threads} {wildcards.experiment}'

rule stratified_by_effect:
    input:
        'results/{experiment}/gene_benchmarks_filter_lfc.rds',
        'results/{experiment}/isoform_benchmarks_filter_lfc.rds'
    output:
        'results/{experiment}/stratified_by_effect.html'
    shell:
        source_rmd('R', 'stratified_by_effect.Rmd',
            '../results/{wildcards.experiment}/stratified_by_effect.html') +
        ' {threads} {wildcards.experiment}'

N_SIM = 20
def get_isoform_dependencies(wildcards):
    exp = wildcards['experiment']
    ret = []
    ret += expand('sims/{exp}/exp_{num}/results/sleuth', exp = exp,
        num = range(1, N_SIM + 1))
    ret += expand('sims/{exp}/exp_{num}/results/cuffdiff/isoform_exp.diff', exp = exp,
        num = range(1, N_SIM + 1))
    return ret
rule benchmark_isoform:
    input:
        get_isoform_dependencies
    output:
        'results/{experiment}/isoform_benchmarks.rds'
    threads:
        N_SIM
    shell:
        source_r('R', 'bench_isoform.R') + ' {threads} {wildcards.experiment}'

rule benchmark_isoform_filter:
    input:
        get_isoform_dependencies
    output:
        'results/{experiment}/isoform_benchmarks_filter.rds'
    threads:
        N_SIM
    shell:
        source_r('R', 'best_filter_isoform.R') + ' {threads} {wildcards.experiment}'

rule benchmark_isoform_filter_lfc:
    input:
        'results/{experiment}/isoform_benchmarks_filter.rds'
    output:
        'results/{experiment}/isoform_benchmarks_filter_lfc.rds'
    threads: 1
    shell:
        source_r('R', 'best_filter_isoform_lfc.R') + ' {threads} {wildcards.experiment}'

rule benchmark_isoform_rsem:
    input:
        'results/{experiment}/isoform_benchmarks_filter_lfc.rds'
        # 'results/{experiment}/exp_1/BitSeq.rds'
    output:
        'results/{experiment}/1/rsem_sleuth.rds'
    threads: 1
    shell:
        source_r('R', 'rsem_sleuth.R') + ' {threads} {wildcards.experiment}'

rule benchmark_report:
    input:
        'results/{experiment}/isoform_benchmarks.rds',
        'results/{experiment}/isoform_benchmarks_filter.rds',
        'results/{experiment}/isoform_benchmarks_filter_lfc.rds',
        'results/{experiment}/gene_benchmarks.rds',
        'results/{experiment}/gene_benchmarks_filter.rds',
        'results/{experiment}/gene_benchmarks_filter_lfc.rds'
    output:
        'results/{experiment}/benchmark_report.html',
        'results/{experiment}/gene_benchmarks_filter_lfc_clean.rds'
    threads:
        1
    shell:
        source_rmd('R', 'benchmark_report.Rmd',
            '../results/{wildcards.experiment}/benchmark_report.html') +
        ' {threads} {wildcards.experiment}'

rule benchmark_isoform_filter_0_variance:
    input:
        'results/{experiment}/isoform_benchmarks_filter_lfc.rds'
    output:
        'results/{experiment}/isoform_benchmarks_filter_zero_variance.rds'
    threads: 20
    shell:
        source_r('R', 'best_filter_0_variance_isoform.R') + ' {threads} {wildcards.experiment}'

rule benchmark_isoform_filter_poisson_variance:
    input:
        'results/{experiment}/isoform_benchmarks_filter_zero_variance.rds'
        # 'results/{experiment}/isoform_benchmarks_filter_lfc.rds'
    output:
        'results/{experiment}/isoform_benchmarks_filter_poisson_variance.rds'
    threads: 20
    shell:
        source_r('R', 'best_filter_poisson_isoform.R') + ' {threads} {wildcards.experiment}'

rule benchmark_gene_filter_0_variance:
    input:
        'results/{experiment}/gene_benchmarks_filter_lfc.rds'
    output:
        'results/{experiment}/gene_benchmarks_filter_0_variance.rds'
    threads: 20
    shell:
        source_r('R', 'best_filter_0_variance_gene.R') + ' {threads} {wildcards.experiment}'


rule benchmark_gene_filter_poisson_variance:
    input:
        'results/{experiment}/gene_benchmarks_filter_0_variance.rds'
    output:
        'results/{experiment}/gene_benchmarks_filter_poisson_variance.rds'
    threads: 20
    shell:
        source_r('R', 'best_filter_poisson_gene.R') + ' {threads} {wildcards.experiment}'

rule benchmark_isoform_filter_smooth_variance:
    input:
        'results/{experiment}/isoform_benchmarks_filter_poisson_variance.rds'
    output:
        'results/{experiment}/isoform_benchmarks_filter_smooth_variance.rds'
    threads: 20
    shell:
        source_r('R', 'best_filter_smooth_isoform.R') + ' {threads} {wildcards.experiment}'

rule benchmark_gene_filter_smooth_variance:
    input:
        'results/{experiment}/gene_benchmarks_filter_poisson_variance.rds'
    output:
        'results/{experiment}/gene_benchmarks_filter_smooth_variance.rds'
    threads: 20
    shell:
        source_r('R', 'best_filter_smooth_gene.R') + ' {threads} {wildcards.experiment}'



rule benchmark_report_0_variance:
    input:
        'results/{experiment}/isoform_benchmarks_filter_zero_variance.rds',
        'results/{experiment}/isoform_benchmarks_filter_smooth_variance.rds'
    output:
        'results/{experiment}/benchmark_report_0_variance.html'
    threads: 1
    shell:
        source_rmd('R', 'benchmark_report_0_variance.Rmd',
            '../results/{wildcards.experiment}/benchmark_report_0_variance.html') +
        ' {threads} {wildcards.experiment}'

rule stratify_results:
    input:
        'results/{experiment}/gene_benchmarks_filter_lfc_clean.rds'
    output:
        'results/{experiment}/stratify_results.html'
    threads: 1
    shell:
        source_rmd('R', 'stratify_results.Rmd',
            '../results/{wildcards.experiment}/stratify_results.html') +
        ' {threads} {wildcards.experiment}'


###
# compute permutations
###

TRAINING_A = []
TRAINING_B = []
TRAINING_FILE_A = 'metadata/training_a.txt'
TRAINING_FILE_B = 'metadata/training_b.txt'
if isfile(TRAINING_FILE_A) and isfile(TRAINING_FILE_B):
    TRAINING_A = get_sample_ids(TRAINING_FILE_A)
    TRAINING_B = get_sample_ids(TRAINING_FILE_B)
    # print(TRAINING_A)
else:
    # force running the init
    print('Warning: the init script has not yet been run. Running now.')
    # rule:
    #     input: rules.init.output

VALIDATION_FILE_A = 'metadata/validation_a.txt'
VALIDATION_FILE_B = 'metadata/validation_b.txt'
if isfile(VALIDATION_FILE_A) and isfile(VALIDATION_FILE_B):
    VALIDATION_A = get_sample_ids(VALIDATION_FILE_A)
    VALIDATION_B = get_sample_ids(VALIDATION_FILE_B)
    # print(VALIDATION_A)
else:
    # force running the init
    print('Warning: the init script has not yet been run. Running now.')
    # rule:
    #     input: rules.init.output

def get_cuffdiff_training(wildcards):
    info = wildcards
    p_num = int(info['p']) - 1
    a = TRAINING_A[p_num].split(' ')
    b = TRAINING_B[p_num].split(' ')
    all_files = a + b
    return expand('sims/{type}_{a}_{b}_{n_sim}_{seed}_{sf}/exp_{num}/{i}/cuffquant/abundances.cxb',
        type = info['type'], a = info['n_a'], b = info['n_b'], n_sim = info['n_sim'],
        seed = info['seed'], sf = info['sf'],
        num = info['num'],
        i = all_files)
rule cuffdiff_training:
    input:
        'sims/{type}_{n_a,\d+}_{n_b}_{n_sim}_{seed,\d+}_{sf,\d+}/sims.rds',
        get_cuffdiff_training
    output:
        'results/training/{type}_{n_a}_{n_b}_{n_sim}_{seed}_{sf}/exp_{num,\d+}/{p}/results/cuffdiff',
        'results/training/{type}_{n_a}_{n_b}_{n_sim}_{seed}_{sf}/exp_{num}/{p}/results/cuffdiff/isoform_exp.diff',
        'results/training/{type}_{n_a}_{n_b}_{n_sim}_{seed}_{sf}/exp_{num}/{p}/results/cuffdiff/gene_exp.diff'
    threads: 3
    run:
        p = int(wildcards['p']) - 1
        info = wildcards
        a = TRAINING_A[p].split(' ')
        b = TRAINING_B[p].split(' ')
        a = expand('sims/{type}_{a}_{b}_{n_sim}_{seed}_{sf}/exp_{num}/{i}/cuffquant/abundances.cxb',
            type = info['type'], a = info['n_a'], b = info['n_b'], n_sim = info['n_sim'],
            seed = info['seed'], sf = info['sf'],
            num = info['num'],
            i = a)
        b = expand('sims/{type}_{a}_{b}_{n_sim}_{seed}_{sf}/exp_{num}/{i}/cuffquant/abundances.cxb',
            type = info['type'], a = info['n_a'], b = info['n_b'], n_sim = info['n_sim'],
            seed = info['seed'], sf = info['sf'],
            num = info['num'],
            i = b)
        cmd = ' '.join([UPDATED_PATH,
            'cuffdiff',
            '-p', str(threads),
            '-o', output[0],
            '-b', GENOME_FA,
            '-u',
            '-q',
            TRANSCRIPTOME_GTF,
            ','.join(a),
            ','.join(b)
            ])
        print(cmd)
        shell(cmd)

def get_cuffdiff_validation(wildcards):
    info = wildcards
    p_num = int(info['p']) - 1
    a = VALIDATION_A[p_num].split(' ')
    b = VALIDATION_B[p_num].split(' ')
    all_files = a + b
    return expand('sims/{type}_{a}_{b}_{n_sim}_{seed}_{sf}/exp_{num}/{i}/cuffquant/abundances.cxb',
        type = info['type'], a = info['n_a'], b = info['n_b'], n_sim = info['n_sim'],
        seed = info['seed'], sf = info['sf'],
        num = info['num'],
        i = all_files)
rule cuffdiff_validation:
    input:
        'sims/{type}_{n_a,\d+}_{n_b}_{n_sim}_{seed,\d+}_{sf,\d+}/sims.rds',
        get_cuffdiff_validation
    output:
        'results/validation/{type}_{n_a}_{n_b}_{n_sim}_{seed}_{sf}/exp_{num,\d+}/{p}/results/cuffdiff',
        'results/validation/{type}_{n_a}_{n_b}_{n_sim}_{seed}_{sf}/exp_{num}/{p}/results/cuffdiff/isoform_exp.diff',
        'results/validation/{type}_{n_a}_{n_b}_{n_sim}_{seed}_{sf}/exp_{num}/{p}/results/cuffdiff/gene_exp.diff'
    threads: 3
    run:
        p = int(wildcards['p']) - 1
        info = wildcards
        a = VALIDATION_A[p].split(' ')
        b = VALIDATION_B[p].split(' ')
        a = expand('sims/{type}_{a}_{b}_{n_sim}_{seed}_{sf}/exp_{num}/{i}/cuffquant/abundances.cxb',
            type = info['type'], a = info['n_a'], b = info['n_b'], n_sim = info['n_sim'],
            seed = info['seed'], sf = info['sf'],
            num = info['num'],
            i = a)
        b = expand('sims/{type}_{a}_{b}_{n_sim}_{seed}_{sf}/exp_{num}/{i}/cuffquant/abundances.cxb',
            type = info['type'], a = info['n_a'], b = info['n_b'], n_sim = info['n_sim'],
            seed = info['seed'], sf = info['sf'],
            num = info['num'],
            i = b)
        cmd = ' '.join([UPDATED_PATH,
            'cuffdiff',
            '-p', str(threads),
            '-o', output[0],
            '-b', GENOME_FA,
            '-u',
            '-q',
            TRANSCRIPTOME_GTF,
            ','.join(a),
            ','.join(b)
            ])
        print(cmd)
        shell(cmd)

rule resampling_report:
    input:
        'results/gfr_10_11_1_43_2/isoform_self_benchmark.rds',
        'results/gfr_10_11_1_43_2/gene_self_benchmark.rds'
    output:
        'results/resampling/resampling_report.html'
    shell:
        source_rmd('R', 'fdr_resampling.Rmd', '../{output}')

rule resampling_isoform:
    input:
        'sims/gfr_10_11_1_43_2/exp_1/results/sleuth',
        expand('results/training/gfr_10_11_1_43_2/exp_1/{p}/results/cuffdiff/isoform_exp.diff',
            p = range(1, 20 + 1)),
        expand('results/validation/gfr_10_11_1_43_2/exp_1/{p}/results/cuffdiff/isoform_exp.diff',
            p = range(1, 20 + 1))
    output:
        'results/gfr_10_11_1_43_2/isoform_self_benchmark.rds'
    threads:
        20
    shell:
        source_r('R', 'resampling_benchmarks.R') +
        ' {threads}'

rule resampling_gene:
    input:
        'sims/gfr_10_11_1_43_2/exp_1/results/sleuth',
        expand('results/training/gfr_10_11_1_43_2/exp_1/{p}/results/cuffdiff/isoform_exp.diff',
            p = range(1, 20 + 1)),
        expand('results/validation/gfr_10_11_1_43_2/exp_1/{p}/results/cuffdiff/isoform_exp.diff',
            p = range(1, 20 + 1)),
        'sims/gfr_10_11_1_43_2/exp_1/results/featureCounts/counts.tsv'
    output:
        'results/gfr_10_11_1_43_2/gene_self_benchmark.rds'
    threads:
        20
    shell:
        source_r('R', 'resampling_benchmarks_gene.R') +
        ' {threads}'

rule resampling_figures_merge:
    input:
        'results/resampling/resampling_report.html'
    output:
        'results/resampling/resampling_figures_merge.html'
    shell:
        source_rmd('R', 'self_fdr_figures.Rmd', '../{output}')

###
# required only for BitSeq
###

rule bowtie_alignment:
    input:
        'sims/{experiment}/exp_{num}/{id}/sim_{id}_1.fq.gz',
        'sims/{experiment}/exp_{num}/{id}/sim_{id}_2.fq.gz'
    output:
        'sims/{experiment}/exp_{num}/{id}/bowtie.bam'
    threads: 10
    benchmark:
        'benchmark/{experiment}/exp_{num}/{id}/bowtie/benchmark.json'
    shell:
        '{UPDATED_PATH}'
        ' bowtie'
        ' -q -v 3 -3 0 -a -m 100 --sam' # recommended arguments from BitSeq
        ' -p {threads}'
        ' {BOWTIE_INDEX}'
        ' -1 <(zcat {input[0]})'
        ' -2 <(zcat {input[1]})'
        ' | '
        '{UPDATED_PATH} samtools view -Sb -'
        ' > '
        '{output}'

# IMPORTANT: for some reason, BitSeq can only run 1 quantification at a time
# if you try to run these in parallel, you will get an error like this:
# [time: +0.03 m]
# [time: +0.03 m]
# [time: +0.03 m]
# [time: +0.03 m]
#
#  *** caught segfault ***
# address (nil), cause 'memory not mapped'
#
# Traceback:
#  1: .C("_parseAlignment", as.integer(argc), as.character(args))
#  2: parseAlignment(alignFile, probF, trSeqFile, trInfoFile = trF,     uniform = uniform, limitA = limitA, expressionFile = exprFile,     pretend = pretend)
#  3: getExpression(alignment_file, transcriptome, out, seed = seed)
#  4: system.time(res <- getExpression(alignment_file, transcriptome,     out, seed = seed))
#  5: eval(expr, envir, enclos)
#  6: eval(ei, envir)
#  7: withVisible(eval(ei, envir))
#  8: source("BitSeq_getExpression.R")
# aborting ...
# [time: +0.03 m]
# [time: +0.02 m]
# Error in job BitSeq_expression while creating output files sims/gfr_3_3_20_42_2/exp_1/6/BitSeq.mean, sims/gfr_3_3_20_42_2/exp_1/6/BitSeq.prob, sims/gfr_3_3_20_42_2/exp_1/6/BitSeq.rpkm, sims/gfr_3_3_20_42_2/exp_1/6/BitSeq.thetaMe
# ans, sims/gfr_3_3_20_42_2/exp_1/6/BitSeq.tr.
# RuleException:
# CalledProcessError in line 709 of /home/hjp/sleuth_paper_analysis/geuvadis/Snakefile:
# Command 'Rscript --vanilla --default-packages=methods,stats,utils -e 'setwd("R")' -e 'source("BitSeq_getExpression.R")' ../sims/gfr_3_3_20_42_2/exp_1/6/bowtie.bam /home/hjp/sleuth_paper_analysis/annotation/Homo_sapiens.GRCh38.cd
# na.all.rel80.fa sims/gfr_3_3_20_42_2/exp_1/6/BitSeq' returned non-zero exit status -11

# defunct, but might use in the future

rule BitSeq_expression:
    input:
        'sims/{experiment}/exp_{num}/{id}/bowtie.bam'
    params:
        prefix = '../sims/{experiment}/exp_{num}/{id}/BitSeq'
    threads: 1
    output:
        'sims/{experiment}/exp_{num}/{id}/BitSeq.mean',
        # 'sims/{experiment}/exp_{num}/{id}/BitSeq.prob',
        'sims/{experiment}/exp_{num}/{id}/BitSeq.rpkm',
        'sims/{experiment}/exp_{num}/{id}/BitSeq.thetaMeans',
        'sims/{experiment}/exp_{num}/{id}/BitSeq.tr'
    benchmark:
        'benchmark/{experiment}/exp_{num}/{id}/BitSeq/benchmark.json'
    shell:
        source_r('R', 'BitSeq_getExpression.R') +
        ' ../{input} {TRANSCRIPTOME_FA} {params.prefix}'

# end defunct

rule BitSeq_expression_parseAlignment:
    input:
        'sims/{experiment}/exp_{num}/{id}/bowtie.bam'
    params:
        prefix = 'sims/{experiment}/exp_{num}/{id}/BitSeq_cli'
    threads: 1
    output:
        # 'sims/{experiment}/exp_{num}/{id}/BitSeq.mean',
        # 'sims/{experiment}/exp_{num}/{id}/BitSeq.prob',
        # 'sims/{experiment}/exp_{num}/{id}/BitSeq.thetaMeans',
        # 'sims/{experiment}/exp_{num}/{id}/BitSeq.tr',
        'sims/{experiment}/exp_{num}/{id}/BitSeq_cli.prob',
        'sims/{experiment}/exp_{num}/{id}/BitSeq_cli.tr'
    benchmark:
        'benchmark/{experiment}/exp_{num}/{id}/BitSeq_cli/parseAlignment.json'
    shell:
        '{UPDATED_PATH} '
        'parseAlignment'
        ' {input}'
        ' -o {output[0]}'
        ' --trSeqFile {TRANSCRIPTOME_FA}'
        ' --trInfoFile {output[1]}'
        ' --uniform'
        ' --verbose'
        # ' data1-1.sam -o data1-1.prob --trSeqFile ensemblGenes.fasta --trInfoFile ensemblGenes.tr --uniform --verbose'

rule BitSeq_expression_getExpression:
    input:
        'sims/{experiment}/exp_{num}/{id}/BitSeq_cli.prob',
        'sims/{experiment}/exp_{num}/{id}/BitSeq_cli.tr'
    params:
        prefix = 'sims/{experiment}/exp_{num}/{id}/BitSeq_cli'
    output:
        'sims/{experiment}/exp_{num}/{id}/BitSeq_cli.rpkm'
    benchmark:
        'benchmark/{experiment}/exp_{num}/{id}/BitSeq_cli/getExpression.json'
    threads: 4
    shell:
        '{UPDATED_PATH} '
        'estimateExpression'
        ' {input[0]}'
        ' -o {params.prefix}'
        ' --outType RPKM'
        ' -t {input[1]}'
        ' --seed {wildcards.num}{wildcards.id}'
        # '$ $BitSeq/estimateExpression data1-1.prob -o data1-1 --outType RPKM -p parameters1.txt -t ensemblGenes.tr -P 2'

rule BitSeq_de:
    input:
        'sims/{experiment}/exp_{num}/{id}/BitSeq_cli.rpkm'
    output:
        'results/{experiment}/exp_{num}/BitSeq_de.rds'
    benchmark:
        'benchmark/{experiment}/exp_{num}/BitSeq_de.json'
    shell:
        '{UPDATED_PATH} '
