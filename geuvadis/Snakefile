include: '../config.py'

isoform_simulations = [
    'sims/isoform_{a}_{b}_{rep}_{seed}_{sf_mode}'.
        format(a = 3, b = 3, rep = 5, seed = 1, sf_mode = 1)
]

def generate_reads(simulation_string):
    base = '{}/exp_'.format(simulation_string)
    mode, n_a, n_b, n_sim, seed, sf = simulation_string.split('_')
    n_sim = int(n_sim)
    n = int(n_a) + int(n_b)
    sims = []
    for i in range(1, n_sim + 1):
        current_experiment = base + str(i)
        for j in range(1, n + 1):
            current_simulation_1 = '{b}/{id}/sim_{id}_1.fq.gz'.format(
                b = current_experiment, id = j)
            current_simulation_2 = '{b}/{id}/sim_{id}_2.fq.gz'.format(
                b = current_experiment, id = j)
            sims.append(current_simulation_1)
            sims.append(current_simulation_2)
    return sims

def generate_base(simulation_string):
    base = '{}/exp_'.format(simulation_string)
    mode, n_a, n_b, n_sim, seed, sf = simulation_string.split('_')
    n_sim = int(n_sim)
    n = int(n_a) + int(n_b)
    sims = []
    for i in range(1, n_sim + 1):
        current_experiment = base + str(i)
        for j in range(1, n + 1):
            sims.append(current_experiment + '/' + str(j))
    return sims

def get_simulation_info(experiment_string):
    mode, a, b, n, seed, sf = experiment_string.split('_')
    result = {
        'mode': mode,
        'a': int(a),
        'b': int(b),
        'n': int(n),
        'seed': int(seed),
        'sf': int(sf)
    }
    return result

def get_all_ids(wildcards, expansion_string):
    info = get_simulation_info(wildcards['experiment'])
    all_ids = range(1, info['a'] + info['b'] + 1)
    print('in here!', all_ids)
    return expand(expansion_string, id = all_ids)

generate_reads(isoform_simulations[0])

def generate_files(specific_replication, suffix):
    return [b + suffix for b in generate_base(specific_replication)]

isoform_reads = [generate_reads(current_reads) for current_reads in isoform_simulations]
isoform_bam = [b + '/hisat.bam' for b in generate_base(isoform_simulations[0])]
isoform_kallisto = [b + '/kallisto/abundance.h5' for b in generate_base(isoform_simulations[0])]
isoform_feature_counts = [b + '/featureCounts.txt' for b in generate_base(isoform_simulations[0])]
# print(isoform_feature_counts)

print(generate_files(isoform_simulations[0], '/hisat.bam'))

# print(isoform_reads[0][0:5])
# print(isoform_bam[0:4])
def get_ids(wildcards, file_prefix, file_suffix):
    experiment = wildcards['experiment']
    num = wildcards['num']

    info = get_simulation_info(experiment)

    # prefix = '{0}/{1}/exp_{2}/{3}'.format(file_prefix, experiment, num, )


rule all:
    input:
        # get all the metadata we need from geuvadis
        'metadata/geu_meta.RData',
        'results/prep_fin.RData',

        # isoform_reads[0][0:5],
        # isoform_bam[0:5],
        # isoform_kallisto[0:6],
        # isoform_feature_counts[0:6],
        #
        # 'sims/isoform_3_3_5_1_1/exp_1/results/cuffdiff/isoform_exp.diff',
        # expand('sims/isoform_3_3_6_1_1/exp_{n}/results/cuffdiff/isoform_exp.diff',
        #     n = range(1, 7)),
        # 'sims/isoform_3_3_5_1_1/exp_1/results/featureCounts/counts.tsv',
        expand('sims/isoform_3_3_20_1_1/exp_{n}/results/sleuth',
            n = range(1, 20 + 1)),
        expand('sims/isoform_3_3_20_1_1/exp_{n}/results/cuffdiff/isoform_exp.diff',
            n = range(1, 20 + 1))

        # isoform_simulations[0:5],
        # isoform_reads[0:5]


rule geuvadis_metadata:
    output:
        'metadata/geu_meta.RData'
    shell:
        source_r('R', 'metadata.R')

rule prep_finnish_samples:
    input:
        'metadata/geu_meta.RData'
    output:
        'results/prep_fin.RData'
    shell:
        source_r('R', 'mean_disp_pairs.R')

###
# simulation generation
###

# this simulation deals with modeling independent differential usage amongst the isoforms
# basically, every isoform is looked at independently and decides whether or not it will be
# differentially expressed independently.
rule gen_sim_script_isoform:
    input:
        'results/prep_fin.RData'
    output:
        'sims/isoform_{n_a,\d+}_{n_b}_{n_sim}_{seed,\d+}_{sf,\d+}',
        'sims/isoform_{n_a,\d+}_{n_b}_{n_sim}_{seed}_{sf}/sims.rds'
    shell:
        source_r('R', 'gen_sim.R') + ' '
        'isoform_{wildcards.n_a}_{wildcards.n_b}_{wildcards.n_sim}_{wildcards.seed}_{wildcards.sf} '
        ' {wildcards.n_sim}'
        ' {wildcards.n_a}'
        ' {wildcards.n_b}'
        ' {wildcards.seed}'
        ' {wildcards.sf}'

rule make_simulation:
    input:
        'sims/{experiment}/sims.rds'
    output:
        'sims/{experiment}/exp_{num}/{id}/sim_{id}_1.fq.gz',
        'sims/{experiment}/exp_{num}/{id}/sim_{id}_2.fq.gz'
    params:
        sims = 'sims/{experiment}/exp_{num}/{id}'
    benchmark:
        'benchmark/{experiment}/exp_{num}/{id}/make_simulation/benchmark.json'
    shell:
        '{UPDATED_PATH}'
        ' {params.sims}/sim_{wildcards.id}.sh'
        ' {RSEM_ANNOTATION}'
        ' {RSEM_MODEL}'
        ' {params.sims}'

rule hisat_alignment:
    input:
        'sims/{experiment}/exp_{num}/{id}/sim_{id}_1.fq.gz',
        'sims/{experiment}/exp_{num}/{id}/sim_{id}_2.fq.gz'
    output:
        'sims/{experiment}/exp_{num}/{id}/hisat.bam'
    threads: 20
    benchmark:
        'benchmark/{experiment}/exp_{num}/{id}/hisat/benchmark.json'
    shell:
        '{UPDATED_PATH}'
        ' hisat2'
        ' -x {HISAT_INDEX}'
        ' -1 {input[0]}'
        ' -2 {input[1]}'
        ' --dta-cufflinks'
        ' -p {threads}'
        ' | '
        '{UPDATED_PATH} samtools view -Sb -'
        ' > '
        '{output}.unsorted'
        ' && '
        '{UPDATED_PATH} samtools sort'
        ' -o {output}'
        ' {output}.unsorted'
        ' && '
        'rm {output}.unsorted'

rule featureCounts:
    input:
        'sims/{experiment}/exp_{num,\d+}/{id,\d+}/hisat.bam'
    output:
        'sims/{experiment}/exp_{num,\d+}/{id,\d+}/featureCounts.txt'
    benchmark:
        'benchmark/{experiment}/exp_{num}/{id}/featureCounts/benchmark.json'
    threads: 5
    shell:
        '{UPDATED_PATH} '
        'featureCounts '
        ' -a {TRANSCRIPTOME_GTF}'
        ' -o {output}'
        ' -T {threads}'
        ' -p'
        ' {input}'

def get_feature_counts(wildcards):
    experiment = wildcards['experiment']
    info = get_simulation_info(experiment)
    num = wildcards['num']
    ids = range(1, info['a'] + info['b'] + 1)

    return expand(
        'sims/{experiment}/exp_{num}/{id}/featureCounts.txt',
        experiment = experiment,
        num = num,
        id = ids)

rule aggregate_counts:
    input:
        get_feature_counts
    output:
        'sims/{experiment}/exp_{num,\d+}/results/featureCounts/counts.tsv'
    params:
        base = 'sims/{experiment}/exp_{num}'
    threads: 1
    shell:
        source_r('R', 'merge_counts.R') +  ' ../{params.base} ../{output}'

rule cuffquant:
    input:
        'sims/{experiment}/exp_{num}/{id}/hisat.bam',
        TRANSCRIPTOME_GTF
    output:
        'sims/{experiment}/exp_{num}/{id}/cuffquant/abundances.cxb'
    threads: 7
    benchmark:
        'benchmark/{experiment}/exp_{num}/{id}/cuffquant/benchmark.json'
    params:
        output = 'sims/{experiment}/exp_{num}/{id}/cuffquant'
    shell:
        '{UPDATED_PATH}'
        ' cuffquant'
        ' -p {threads}'
        ' -o {params.output}'
        ' -b {GENOME_FA}'
        ' -u'
        ' -q'
        ' {TRANSCRIPTOME_GTF}'
        ' {input[0]}'

def get_cuffdiff(wildcards):
    experiment = wildcards['experiment']
    info = get_simulation_info(experiment)
    num = wildcards['num']
    ids = range(1, info['a'] + info['b'] + 1)

    return expand('sims/{experiment}/exp_{num}/{id}/cuffquant/abundances.cxb',
        experiment = experiment,
        num = num,
        id = ids)

rule cuffdiff:
    input:
        get_cuffdiff
    output:
        'sims/{experiment}/exp_{num,\d+}/results/cuffdiff',
        'sims/{experiment}/exp_{num}/results/cuffdiff/isoform_exp.diff',
        'sims/{experiment}/exp_{num}/results/cuffdiff/gene_exp.diff'
    benchmark:
        'benchmark/{experiment}/exp_{num}/cuffdiff/benchmark.json'
    threads: 3
    run:
        info = get_simulation_info(wildcards['experiment'])
        # I'm not sure if this is necessary, but at least this ensures they are sorted correctly
        input.sort(key = lambda x: int(x.split('/')[3]))
        left = [input[i] for i in range(0, info['a'])]
        right = [input[i] for i in range(info['a'], info['a'] + info['b'])]

        cmd = ' '.join([UPDATED_PATH,
            'cuffdiff',
            '-p', str(threads),
            '-o', output[0],
            '-b', GENOME_FA,
            '-u',
            '-q',
            TRANSCRIPTOME_GTF,
            ','.join(left),
            ','.join(right)
            ])
        print(cmd)
        shell(cmd)

rule kallisto:
    input:
        'sims/{experiment}/exp_{num}/{id}/sim_{id}_1.fq.gz',
        'sims/{experiment}/exp_{num}/{id}/sim_{id}_2.fq.gz'
    output:
        'sims/{experiment}/exp_{num}/{id}/kallisto',
        'sims/{experiment}/exp_{num}/{id}/kallisto/abundance.h5',
        'sims/{experiment}/exp_{num}/{id}/kallisto/abundance.tsv'
    benchmark:
        'benchmark/{experiment}/exp_{num}/{id}/kallisto/benchmark.json'
    threads: 5
    shell:
        '{UPDATED_PATH} '
        'kallisto quant'
        ' -i {KALLISTO_INDEX}'
        ' -b 100'
        ' -o {output[0]}'
        ' -t {threads}'
        ' {input[0]} {input[1]}'
        # ' <(zcat {input[0]}) <(zcat {input[1]})'

def get_sleuth(wildcards):
    experiment = wildcards['experiment']
    info = get_simulation_info(experiment)
    num = wildcards['num']
    ids = range(1, info['a'] + info['b'] + 1)
    return expand('sims/{experiment}/exp_{num}/{id}/kallisto/abundance.h5',
        experiment = experiment,
        num = num,
        id = ids)

rule sleuth:
    input:
        get_sleuth
    output:
        'sims/{experiment}/exp_{num,\d+}/results/sleuth'
    shell:
        'touch {output}'
